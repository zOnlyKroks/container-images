name: Build and Publish Container Image

on:
  workflow_dispatch:
    inputs:
      push_to_dockerhub:
        description: 'Push to Docker Hub'
        required: false
        type: boolean
        default: true
      push_to_ghcr:
        description: 'Push to GitHub Container Registry'
        required: false
        type: boolean
        default: true
      sign_images:
        description: 'Sign images with Cosign'
        required: false
        type: boolean
        default: true
      run_security_scan:
        description: 'Run Trivy security scan'
        required: false
        type: boolean
        default: true
      platforms:
        description: 'Target platforms (leave empty to use config.yaml defaults)'
        required: false
        type: string
        default: ''
      tag_suffix:
        description: 'Optional tag suffix (e.g., "rc1", "beta")'
        required: false
        type: string
        default: ''

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.changed-images.outputs.images }}
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0

      - name: Detect changed images
        id: changed-images
        run: |
          set -euo pipefail

          # Parse input images
          INPUT_IMAGES="${{ github.event.inputs.images }}"

          if [ "$INPUT_IMAGES" = "all" ]; then
            # Build all available images
            CHANGED_IMAGES=$(ls -1 images/ | tr '\n' ' ')
            echo "Building all images: $CHANGED_IMAGES"
          else
            # Build specific images (comma or space separated)
            CHANGED_IMAGES=$(echo "$INPUT_IMAGES" | tr ',' ' ')
            echo "Building specific images: $CHANGED_IMAGES"
          fi

          echo "images=$CHANGED_IMAGES" >> $GITHUB_OUTPUT

      - name: Set matrix
        id: set-matrix
        run: |
          IMAGES="${{ steps.changed-images.outputs.images }}"
          HAS_IMAGES="false"

          if [ -z "$IMAGES" ] || [ "$IMAGES" = " " ]; then
            # No images to build - create empty matrix with dummy entry
            # The build job will be skipped via the 'if' condition
            echo "matrix={\"include\":[{\"image\":\"none\"}]}" >> $GITHUB_OUTPUT
            echo "has_images=false" >> $GITHUB_OUTPUT
            echo "No images to build"
          else
            JSON_ARRAY="["
            FOUND_VALID_IMAGE=false
            for img in $IMAGES; do
              if [ -d "images/$img" ] && [ -f "images/$img/config.yaml" ]; then
                JSON_ARRAY="$JSON_ARRAY{\"image\":\"$img\"},"
                FOUND_VALID_IMAGE=true
              fi
            done

            if [ "$FOUND_VALID_IMAGE" = "true" ]; then
              JSON_ARRAY="${JSON_ARRAY%,}]"
              HAS_IMAGES="true"
            else
              # No valid images found - create dummy entry
              JSON_ARRAY="[{\"image\":\"none\"}]"
              HAS_IMAGES="false"
            fi

            echo "matrix={\"include\":$JSON_ARRAY}" >> $GITHUB_OUTPUT
            echo "has_images=$HAS_IMAGES" >> $GITHUB_OUTPUT
            echo "Matrix: $JSON_ARRAY"
          fi

  # Build AMD64 images on native AMD64 runners
  build-amd64:
    needs: detect-changes
    if: needs.detect-changes.outputs.matrix != '' && fromJson(needs.detect-changes.outputs.matrix).include[0].image != 'none'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    outputs:
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1
        with:
          # Enable inline cache for better performance
          buildkitd-flags: --debug

      - name: Check credentials availability
        id: check-creds
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          COSIGN_KEY: ${{ secrets.COSIGN_KEY }}
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        run: |
          HAS_DOCKERHUB_CREDS="false"
          HAS_COSIGN_CREDS="false"

          if [ -n "$DOCKERHUB_USERNAME" ] && [ -n "$DOCKERHUB_TOKEN" ]; then
            HAS_DOCKERHUB_CREDS="true"
            echo "✓ Docker Hub credentials available"
          else
            echo "⚠ Docker Hub credentials not available - publishing to Docker Hub will be skipped"
          fi

          if [ -n "$COSIGN_KEY" ] && [ -n "$COSIGN_PASSWORD" ]; then
            HAS_COSIGN_CREDS="true"
            echo "✓ Cosign credentials available"
          else
            echo "⚠ Cosign credentials not available - image signing will be skipped"
          fi

          echo "dockerhub=$HAS_DOCKERHUB_CREDS" >> $GITHUB_OUTPUT
          echo "cosign=$HAS_COSIGN_CREDS" >> $GITHUB_OUTPUT

      - name: Login to Docker Hub
        if: github.event.inputs.push_to_dockerhub == 'true' && steps.check-creds.outputs.dockerhub == 'true'
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GHCR
        if: github.event.inputs.push_to_ghcr == 'true'
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Parse image configuration
        id: config
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          CONFIG_FILE="images/$IMAGE_NAME/config.yaml"

          if [ ! -f "$CONFIG_FILE" ]; then
            echo "ERROR: Configuration file not found: $CONFIG_FILE"
            exit 1
          fi

          # Parse config.yaml
          BASE_IMAGE=$(yq eval '.base_image' "$CONFIG_FILE")
          VERSION=$(yq eval '.version' "$CONFIG_FILE")
          DESCRIPTION=$(yq eval '.description // ""' "$CONFIG_FILE")

          # For platform-specific builds, we only build one platform at a time
          PLATFORM="linux/amd64"
          echo "Building for platform: $PLATFORM"

          BUILD_ARGS=$(yq eval '.build_args // {}' "$CONFIG_FILE" -o json -I=0)

          # Get GitHub repo owner in lowercase
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')

          # Apply tag suffix if provided
          TAG_SUFFIX=""
          if [ -n "${{ github.event.inputs.tag_suffix }}" ]; then
            TAG_SUFFIX="-${{ github.event.inputs.tag_suffix }}"
          fi

          # Build platform-specific tags (will be merged later into multi-arch manifest)
          TAGS=""

          # Add Docker Hub tags if enabled and credentials are available
          if [ "${{ github.event.inputs.push_to_dockerhub }}" = "true" ] && [ "${{ steps.check-creds.outputs.dockerhub }}" = "true" ]; then
            DOCKERHUB_USER="${{ secrets.DOCKERHUB_USERNAME }}"
            TAGS="${DOCKERHUB_USER}/$IMAGE_NAME:$VERSION$TAG_SUFFIX-amd64"
          fi

          # Add GHCR tags if enabled
          if [ "${{ github.event.inputs.push_to_ghcr }}" = "true" ]; then
            if [ -n "$TAGS" ]; then
              TAGS="$TAGS,ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION$TAG_SUFFIX-amd64"
            else
              TAGS="ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION$TAG_SUFFIX-amd64"
            fi
          fi

          # If no registry is selected, use a local tag for build-only
          if [ -z "$TAGS" ]; then
            echo "⚠️ No registry selected - building without push"
            TAGS="local/$IMAGE_NAME:$VERSION$TAG_SUFFIX-amd64"
          fi

          echo "base_image=$BASE_IMAGE" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "platform=$PLATFORM" >> $GITHUB_OUTPUT
          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "build_args=$BUILD_ARGS" >> $GITHUB_OUTPUT

          echo "Building $IMAGE_NAME:$VERSION from $BASE_IMAGE for $PLATFORM"
          echo "Tags: $TAGS"
          echo "Cache scope: $IMAGE_NAME-amd64"

      - name: Apply patches
        id: patches
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          PATCHES_DIR="images/$IMAGE_NAME/patches"

          if [ -d "$PATCHES_DIR" ] && [ "$(ls -A $PATCHES_DIR/*.patch 2>/dev/null)" ]; then
            echo "Applying patches for $IMAGE_NAME..."

            # Create temporary directory for patched files
            mkdir -p "/tmp/$IMAGE_NAME-patched"

            # Apply each patch
            for patch in $PATCHES_DIR/*.patch; do
              echo "Applying patch: $(basename $patch)"
              patch -p1 -d "/tmp/$IMAGE_NAME-patched" < "$patch" || {
                echo "ERROR: Failed to apply patch: $patch"
                exit 1
              }
            done

            echo "patched=true" >> $GITHUB_OUTPUT
            echo "patch_dir=/tmp/$IMAGE_NAME-patched" >> $GITHUB_OUTPUT
          else
            echo "No patches to apply"
            echo "patched=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate Dockerfile
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          BASE_IMAGE="${{ steps.config.outputs.base_image }}"
          VERSION="${{ steps.config.outputs.version }}"

          DOCKERFILE="images/$IMAGE_NAME/Dockerfile.generated"
          CUSTOM_DOCKERFILE="images/$IMAGE_NAME/Dockerfile"

          # Use custom Dockerfile if it exists, otherwise generate one
          if [ -f "$CUSTOM_DOCKERFILE" ]; then
            echo "Using custom Dockerfile"
            cp "$CUSTOM_DOCKERFILE" "$DOCKERFILE"
          else
            echo "Generating Dockerfile"
            cat > "$DOCKERFILE" <<EOF
          FROM $BASE_IMAGE

          LABEL org.opencontainers.image.source="https://github.com/${{ github.repository }}"
          LABEL org.opencontainers.image.description="${{ steps.config.outputs.description }}"
          LABEL org.opencontainers.image.version="$VERSION"
          LABEL org.opencontainers.image.vendor="CloudPirates"
          LABEL org.opencontainers.image.licenses="Apache-2.0"

          # Copy patches if they exist
          EOF

            if [ "${{ steps.patches.outputs.patched }}" = "true" ]; then
              echo "COPY --from=patches / /" >> "$DOCKERFILE"
            fi

            # Add custom setup script if it exists
            if [ -f "images/$IMAGE_NAME/setup.sh" ]; then
              cat >> "$DOCKERFILE" <<EOF

          COPY setup.sh /tmp/setup.sh
          RUN chmod +x /tmp/setup.sh && /tmp/setup.sh && rm /tmp/setup.sh
          EOF
            fi
          fi

          echo "Generated Dockerfile:"
          cat "$DOCKERFILE"

      - name: Build and push AMD64
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: images/${{ matrix.image }}
          file: images/${{ matrix.image }}/Dockerfile.generated
          platforms: ${{ steps.config.outputs.platform }}
          # Always push platform-specific images (needed for manifest merge)
          push: true
          tags: ${{ steps.config.outputs.tags }}
          # Platform-specific caching
          cache-from: type=gha,scope=${{ matrix.image }}-amd64
          cache-to: type=gha,mode=max,scope=${{ matrix.image }}-amd64
          labels: |
            org.opencontainers.image.source=${{ github.event.repository.html_url }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
            org.opencontainers.image.revision=${{ github.sha }}
          # Generate SBOM and provenance attestations
          sbom: true
          provenance: true
          outputs: type=image,name=target,annotation-index.org.opencontainers.image.description=${{ steps.config.outputs.description }}
          # Show detailed build progress
          build-args: |
            BUILDKIT_PROGRESS=plain

  # Build ARM64 images on native ARM64 runners
  build-arm64:
    needs: detect-changes
    if: needs.detect-changes.outputs.matrix != '' && fromJson(needs.detect-changes.outputs.matrix).include[0].image != 'none'
    runs-on: ubuntu-24.04-arm  # Native ARM64 runner for fast compilation
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    outputs:
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1
        with:
          buildkitd-flags: --debug

      - name: Check credentials availability
        id: check-creds
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          HAS_DOCKERHUB_CREDS="false"
          if [ -n "$DOCKERHUB_USERNAME" ] && [ -n "$DOCKERHUB_TOKEN" ]; then
            HAS_DOCKERHUB_CREDS="true"
            echo "✓ Docker Hub credentials available"
          else
            echo "⚠ Docker Hub credentials not available"
          fi
          echo "dockerhub=$HAS_DOCKERHUB_CREDS" >> $GITHUB_OUTPUT

      - name: Login to Docker Hub
        if: github.event.inputs.push_to_dockerhub == 'true' && steps.check-creds.outputs.dockerhub == 'true'
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GHCR
        if: github.event.inputs.push_to_ghcr == 'true'
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_arm64
          sudo chmod +x /usr/local/bin/yq

      - name: Parse image configuration
        id: config
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          CONFIG_FILE="images/$IMAGE_NAME/config.yaml"

          if [ ! -f "$CONFIG_FILE" ]; then
            echo "ERROR: Configuration file not found: $CONFIG_FILE"
            exit 1
          fi

          BASE_IMAGE=$(yq eval '.base_image' "$CONFIG_FILE")
          VERSION=$(yq eval '.version' "$CONFIG_FILE")
          DESCRIPTION=$(yq eval '.description // ""' "$CONFIG_FILE")

          # For platform-specific builds, we only build one platform at a time
          PLATFORM="linux/arm64"
          echo "Building for platform: $PLATFORM"

          BUILD_ARGS=$(yq eval '.build_args // {}' "$CONFIG_FILE" -o json -I=0)
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')

          # Apply tag suffix if provided
          TAG_SUFFIX=""
          if [ -n "${{ github.event.inputs.tag_suffix }}" ]; then
            TAG_SUFFIX="-${{ github.event.inputs.tag_suffix }}"
          fi

          # Build platform-specific tags (will be merged later into multi-arch manifest)
          TAGS=""
          if [ "${{ github.event.inputs.push_to_dockerhub }}" = "true" ] && [ "${{ steps.check-creds.outputs.dockerhub }}" = "true" ]; then
            DOCKERHUB_USER="${{ secrets.DOCKERHUB_USERNAME }}"
            TAGS="${DOCKERHUB_USER}/$IMAGE_NAME:$VERSION$TAG_SUFFIX-arm64"
          fi

          if [ "${{ github.event.inputs.push_to_ghcr }}" = "true" ]; then
            if [ -n "$TAGS" ]; then
              TAGS="$TAGS,ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION$TAG_SUFFIX-arm64"
            else
              TAGS="ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION$TAG_SUFFIX-arm64"
            fi
          fi

          if [ -z "$TAGS" ]; then
            echo "⚠️ No registry selected - building without push"
            TAGS="local/$IMAGE_NAME:$VERSION$TAG_SUFFIX-arm64"
          fi

          echo "base_image=$BASE_IMAGE" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "platform=$PLATFORM" >> $GITHUB_OUTPUT
          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "build_args=$BUILD_ARGS" >> $GITHUB_OUTPUT

          echo "Building $IMAGE_NAME:$VERSION from $BASE_IMAGE for $PLATFORM"
          echo "Tags: $TAGS"
          echo "Cache scope: $IMAGE_NAME-arm64"

      - name: Apply patches
        id: patches
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          PATCHES_DIR="images/$IMAGE_NAME/patches"

          if [ -d "$PATCHES_DIR" ] && [ "$(ls -A $PATCHES_DIR/*.patch 2>/dev/null)" ]; then
            echo "Applying patches for $IMAGE_NAME..."
            mkdir -p "/tmp/$IMAGE_NAME-patched"
            for patch in $PATCHES_DIR/*.patch; do
              echo "Applying patch: $(basename $patch)"
              patch -p1 -d "/tmp/$IMAGE_NAME-patched" < "$patch" || {
                echo "ERROR: Failed to apply patch: $patch"
                exit 1
              }
            done
            echo "patched=true" >> $GITHUB_OUTPUT
            echo "patch_dir=/tmp/$IMAGE_NAME-patched" >> $GITHUB_OUTPUT
          else
            echo "No patches to apply"
            echo "patched=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate Dockerfile
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          BASE_IMAGE="${{ steps.config.outputs.base_image }}"
          VERSION="${{ steps.config.outputs.version }}"

          DOCKERFILE="images/$IMAGE_NAME/Dockerfile.generated"
          CUSTOM_DOCKERFILE="images/$IMAGE_NAME/Dockerfile"

          if [ -f "$CUSTOM_DOCKERFILE" ]; then
            echo "Using custom Dockerfile"
            cp "$CUSTOM_DOCKERFILE" "$DOCKERFILE"
          else
            echo "Generating Dockerfile"
            cat > "$DOCKERFILE" <<EOF
          FROM $BASE_IMAGE

          LABEL org.opencontainers.image.source="https://github.com/${{ github.repository }}"
          LABEL org.opencontainers.image.description="${{ steps.config.outputs.description }}"
          LABEL org.opencontainers.image.version="$VERSION"
          LABEL org.opencontainers.image.vendor="CloudPirates"
          LABEL org.opencontainers.image.licenses="Apache-2.0"

          # Copy patches if they exist
          EOF

            if [ "${{ steps.patches.outputs.patched }}" = "true" ]; then
              echo "COPY --from=patches / /" >> "$DOCKERFILE"
            fi

            if [ -f "images/$IMAGE_NAME/setup.sh" ]; then
              cat >> "$DOCKERFILE" <<EOF

          COPY setup.sh /tmp/setup.sh
          RUN chmod +x /tmp/setup.sh && /tmp/setup.sh && rm /tmp/setup.sh
          EOF
            fi
          fi

          echo "Generated Dockerfile:"
          cat "$DOCKERFILE"

      - name: Build and push ARM64
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: images/${{ matrix.image }}
          file: images/${{ matrix.image }}/Dockerfile.generated
          platforms: ${{ steps.config.outputs.platform }}
          # Always push platform-specific images (needed for manifest merge)
          push: true
          tags: ${{ steps.config.outputs.tags }}
          cache-from: type=gha,scope=${{ matrix.image }}-arm64
          cache-to: type=gha,mode=max,scope=${{ matrix.image }}-arm64
          labels: |
            org.opencontainers.image.source=${{ github.event.repository.html_url }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
            org.opencontainers.image.revision=${{ github.sha }}
          sbom: true
          provenance: true
          outputs: type=image,name=target,annotation-index.org.opencontainers.image.description=${{ steps.config.outputs.description }}
          build-args: |
            BUILDKIT_PROGRESS=plain

  # Merge multi-arch manifests and perform security scanning/signing
  merge-and-publish:
    needs: [detect-changes, build-amd64, build-arm64]
    if: needs.detect-changes.outputs.matrix != '' && fromJson(needs.detect-changes.outputs.matrix).include[0].image != 'none'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
      packages: write
      security-events: write
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      - name: Check credentials availability
        id: check-creds
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          COSIGN_KEY: ${{ secrets.COSIGN_KEY }}
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        run: |
          HAS_DOCKERHUB_CREDS="false"
          HAS_COSIGN_CREDS="false"

          if [ -n "$DOCKERHUB_USERNAME" ] && [ -n "$DOCKERHUB_TOKEN" ]; then
            HAS_DOCKERHUB_CREDS="true"
            echo "✓ Docker Hub credentials available"
          else
            echo "⚠ Docker Hub credentials not available"
          fi

          if [ -n "$COSIGN_KEY" ] && [ -n "$COSIGN_PASSWORD" ]; then
            HAS_COSIGN_CREDS="true"
            echo "✓ Cosign credentials available"
          else
            echo "⚠ Cosign credentials not available"
          fi

          echo "dockerhub=$HAS_DOCKERHUB_CREDS" >> $GITHUB_OUTPUT
          echo "cosign=$HAS_COSIGN_CREDS" >> $GITHUB_OUTPUT

      - name: Login to Docker Hub
        if: github.event.inputs.push_to_dockerhub == 'true' && steps.check-creds.outputs.dockerhub == 'true'
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GHCR
        if: github.event.inputs.push_to_ghcr == 'true'
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Parse image configuration
        id: config
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          CONFIG_FILE="images/$IMAGE_NAME/config.yaml"

          VERSION=$(yq eval '.version' "$CONFIG_FILE")
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')

          # Apply tag suffix if provided
          TAG_SUFFIX=""
          if [ -n "${{ github.event.inputs.tag_suffix }}" ]; then
            TAG_SUFFIX="-${{ github.event.inputs.tag_suffix }}"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag_suffix=$TAG_SUFFIX" >> $GITHUB_OUTPUT
          echo "repo_owner=$REPO_OWNER" >> $GITHUB_OUTPUT

      - name: Create multi-arch manifest
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          VERSION="${{ steps.config.outputs.version }}"
          TAG_SUFFIX="${{ steps.config.outputs.tag_suffix }}"
          REPO_OWNER="${{ steps.config.outputs.repo_owner }}"

          # Create and push multi-arch manifests
          if [ "${{ github.event.inputs.push_to_dockerhub }}" = "true" ] && [ "${{ steps.check-creds.outputs.dockerhub }}" = "true" ]; then
            DOCKERHUB_USER="${{ secrets.DOCKERHUB_USERNAME }}"

            echo "Creating Docker Hub multi-arch manifest..."
            docker buildx imagetools create -t ${DOCKERHUB_USER}/$IMAGE_NAME:$VERSION$TAG_SUFFIX \
              ${DOCKERHUB_USER}/$IMAGE_NAME:$VERSION$TAG_SUFFIX-amd64 \
              ${DOCKERHUB_USER}/$IMAGE_NAME:$VERSION$TAG_SUFFIX-arm64

            # Create latest tag if no suffix
            if [ -z "$TAG_SUFFIX" ]; then
              docker buildx imagetools create -t ${DOCKERHUB_USER}/$IMAGE_NAME:latest \
                ${DOCKERHUB_USER}/$IMAGE_NAME:$VERSION-amd64 \
                ${DOCKERHUB_USER}/$IMAGE_NAME:$VERSION-arm64
            fi
          fi

          if [ "${{ github.event.inputs.push_to_ghcr }}" = "true" ]; then
            echo "Creating GHCR multi-arch manifest..."
            docker buildx imagetools create -t ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION$TAG_SUFFIX \
              ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION$TAG_SUFFIX-amd64 \
              ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION$TAG_SUFFIX-arm64

            # Create latest tag if no suffix
            if [ -z "$TAG_SUFFIX" ]; then
              docker buildx imagetools create -t ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:latest \
                ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION-amd64 \
                ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION-arm64
            fi
          fi

          echo "✅ Multi-arch manifest created successfully"

      - name: Clean up platform-specific tags
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          VERSION="${{ steps.config.outputs.version }}"
          TAG_SUFFIX="${{ steps.config.outputs.tag_suffix }}"
          REPO_OWNER="${{ steps.config.outputs.repo_owner }}"

          echo "Cleaning up intermediate platform-specific tags..."

          # Note: We can't easily delete tags from Docker Hub via CLI, but we can delete from GHCR
          # For Docker Hub, users can manually delete the -amd64/-arm64 tags if desired
          # The multi-arch manifests are what users should pull anyway

          if [ "${{ github.event.inputs.push_to_ghcr }}" = "true" ]; then
            # Delete platform-specific tags from GHCR using GitHub API
            echo "Deleting GHCR platform-specific tags..."

            for ARCH in amd64 arm64; do
              TAG="$VERSION$TAG_SUFFIX-$ARCH"
              echo "Attempting to delete ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$TAG"

              # Get package version ID
              PACKAGE_VERSION_ID=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/users/$REPO_OWNER/packages/container/container-images%2F$IMAGE_NAME/versions" \
                | jq -r ".[] | select(.metadata.container.tags[] | contains(\"$TAG\")) | .id" | head -n1)

              if [ -n "$PACKAGE_VERSION_ID" ] && [ "$PACKAGE_VERSION_ID" != "null" ]; then
                curl -X DELETE -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/users/$REPO_OWNER/packages/container/container-images%2F$IMAGE_NAME/versions/$PACKAGE_VERSION_ID" \
                  && echo "✅ Deleted $TAG" || echo "⚠️ Failed to delete $TAG"
              else
                echo "⚠️ Could not find version ID for $TAG"
              fi
            done
          fi

          if [ "${{ github.event.inputs.push_to_dockerhub }}" = "true" ] && [ "${{ steps.check-creds.outputs.dockerhub }}" = "true" ]; then
            echo "Deleting Docker Hub platform-specific tags..."
            DOCKERHUB_USER="${{ secrets.DOCKERHUB_USERNAME }}"

            # Get Docker Hub token
            DOCKERHUB_TOKEN=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -d "{\"username\":\"$DOCKERHUB_USER\",\"password\":\"${{ secrets.DOCKERHUB_TOKEN }}\"}" \
              https://hub.docker.com/v2/users/login/ | jq -r .token)

            if [ -n "$DOCKERHUB_TOKEN" ] && [ "$DOCKERHUB_TOKEN" != "null" ]; then
              for ARCH in amd64 arm64; do
                TAG="$VERSION$TAG_SUFFIX-$ARCH"
                echo "Attempting to delete Docker Hub tag: $TAG"

                curl -X DELETE \
                  -H "Authorization: JWT $DOCKERHUB_TOKEN" \
                  "https://hub.docker.com/v2/repositories/$DOCKERHUB_USER/$IMAGE_NAME/tags/$TAG/" \
                  && echo "✅ Deleted $TAG from Docker Hub" || echo "⚠️ Failed to delete $TAG from Docker Hub"
              done
            else
              echo "⚠️ Failed to get Docker Hub token for cleanup"
            fi
          fi

      - name: Wait for image to be available
        if: github.event.inputs.push_to_ghcr == 'true' && github.event.inputs.run_security_scan == 'true'
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          VERSION="${{ steps.config.outputs.version }}"
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_REF="ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION"

          echo "Waiting for image to be available: $IMAGE_REF"

          # Wait up to 60 seconds for image to be pullable
          RETRIES=30
          until docker pull "$IMAGE_REF" >/dev/null 2>&1; do
            RETRIES=$((RETRIES - 1))
            if [ $RETRIES -eq 0 ]; then
              echo "⚠️  Image not available yet, continuing anyway"
              break
            fi
            echo "Waiting for image... ($RETRIES attempts remaining)"
            sleep 2
          done

          echo "Image is available"

      - name: Set image reference for scanning
        if: github.event.inputs.run_security_scan == 'true' && github.event.inputs.push_to_ghcr == 'true'
        id: scan-ref
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')

          # Apply tag suffix if provided
          TAG_SUFFIX=""
          if [ -n "${{ github.event.inputs.tag_suffix }}" ]; then
            TAG_SUFFIX="-${{ github.event.inputs.tag_suffix }}"
          fi

          IMAGE_REF="ghcr.io/$REPO_OWNER/container-images/${{ matrix.image }}:${{ steps.config.outputs.version }}$TAG_SUFFIX"
          echo "image_ref=$IMAGE_REF" >> $GITHUB_OUTPUT
          echo "Scanning image: $IMAGE_REF"

      - name: Run Trivy vulnerability scanner
        if: github.event.inputs.run_security_scan == 'true' && github.event.inputs.push_to_ghcr == 'true'
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # v0.33.1
        with:
          image-ref: ${{ steps.scan-ref.outputs.image_ref }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
        continue-on-error: true

      - name: Upload Trivy results to GitHub Security
        if: github.event.inputs.run_security_scan == 'true' && github.event.inputs.push_to_ghcr == 'true'
        uses: github/codeql-action/upload-sarif@16140ae1a102900babc80a33c44059580f687047 # v3.28.5
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true

      - name: Run Trivy for summary
        if: github.event.inputs.run_security_scan == 'true' && github.event.inputs.push_to_ghcr == 'true'
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # v0.33.1
        with:
          image-ref: ${{ steps.scan-ref.outputs.image_ref }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'
        continue-on-error: true

      - name: Install cosign
        if: github.event.inputs.sign_images == 'true' && steps.check-creds.outputs.cosign == 'true'
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0

      - name: Sign images
        if: github.event.inputs.sign_images == 'true' && steps.check-creds.outputs.cosign == 'true'
        env:
          COSIGN_KEY: ${{ secrets.COSIGN_KEY }}
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        run: |
          set -euo pipefail

          IMAGE_NAME="${{ matrix.image }}"
          VERSION="${{ steps.config.outputs.version }}"
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')

          # Apply tag suffix if provided
          TAG_SUFFIX=""
          if [ -n "${{ github.event.inputs.tag_suffix }}" ]; then
            TAG_SUFFIX="-${{ github.event.inputs.tag_suffix }}"
          fi

          # Sign Docker Hub image if push is enabled
          if [ "${{ github.event.inputs.push_to_dockerhub }}" = "true" ] && [ "${{ steps.check-creds.outputs.dockerhub }}" = "true" ]; then
            DOCKERHUB_USER="${{ secrets.DOCKERHUB_USERNAME }}"
            echo "Signing Docker Hub image..."
            cosign sign -y --key env://COSIGN_KEY \
              ${DOCKERHUB_USER}/$IMAGE_NAME:$VERSION$TAG_SUFFIX
          fi

          # Sign GHCR image if push is enabled
          if [ "${{ github.event.inputs.push_to_ghcr }}" = "true" ]; then
            echo "Signing GHCR image..."
            cosign sign -y --key env://COSIGN_KEY \
              ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION$TAG_SUFFIX
          fi

          echo "Successfully signed images for $IMAGE_NAME:$VERSION$TAG_SUFFIX"

      - name: Generate job summary
        run: |
          IMAGE_NAME="${{ matrix.image }}"
          VERSION="${{ steps.config.outputs.version }}"
          TAG_SUFFIX="${{ steps.config.outputs.tag_suffix }}"

          echo "## Multi-Arch Container Image Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Successfully built **$IMAGE_NAME:$VERSION$TAG_SUFFIX** for multiple architectures" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show build configuration
          echo "### Build Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Platforms**: linux/amd64, linux/arm64" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Method**: Native builds on platform-specific runners (no QEMU)" >> $GITHUB_STEP_SUMMARY
          if [ -n "$TAG_SUFFIX" ]; then
            echo "- **Tag Suffix**: $TAG_SUFFIX" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show publishing status
          echo "### Publishing Status" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.push_to_dockerhub }}" = "true" ]; then
            if [ "${{ steps.check-creds.outputs.dockerhub }}" = "true" ]; then
              echo "✅ Published to Docker Hub" >> $GITHUB_STEP_SUMMARY
            else
              echo "⚠️  Docker Hub credentials not available - publishing skipped" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "⏭️  Docker Hub push disabled" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ github.event.inputs.push_to_ghcr }}" = "true" ]; then
            echo "✅ Published to GHCR" >> $GITHUB_STEP_SUMMARY
          else
            echo "⏭️  GHCR push disabled" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show signing status
          echo "### Security" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.sign_images }}" = "true" ]; then
            if [ "${{ steps.check-creds.outputs.cosign }}" = "true" ]; then
              echo "✅ Images signed with Cosign" >> $GITHUB_STEP_SUMMARY
            else
              echo "⚠️  Cosign credentials not available - signing skipped" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "⏭️  Image signing disabled" >> $GITHUB_STEP_SUMMARY
          fi

          echo "✅ SBOM generated" >> $GITHUB_STEP_SUMMARY
          echo "✅ Provenance attestation created" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event.inputs.run_security_scan }}" = "true" ]; then
            if [ "${{ github.event.inputs.push_to_ghcr }}" = "true" ]; then
              echo "✅ Vulnerability scan completed (check Security tab for details)" >> $GITHUB_STEP_SUMMARY
            else
              echo "⚠️  Security scan requires GHCR push to be enabled" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "⏭️  Security scan disabled" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show pull commands only for enabled registries
          REPO_OWNER="${{ steps.config.outputs.repo_owner }}"

          echo "### Pull Commands" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event.inputs.push_to_dockerhub }}" = "true" ] && [ "${{ steps.check-creds.outputs.dockerhub }}" = "true" ]; then
            DOCKERHUB_USER="${{ secrets.DOCKERHUB_USERNAME }}"
            echo "# From Docker Hub (multi-arch)" >> $GITHUB_STEP_SUMMARY
            echo "docker pull ${DOCKERHUB_USER}/$IMAGE_NAME:$VERSION$TAG_SUFFIX" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ github.event.inputs.push_to_ghcr }}" = "true" ]; then
            echo "# From GHCR (multi-arch)" >> $GITHUB_STEP_SUMMARY
            echo "docker pull ghcr.io/$REPO_OWNER/container-images/$IMAGE_NAME:$VERSION$TAG_SUFFIX" >> $GITHUB_STEP_SUMMARY
          fi

          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
